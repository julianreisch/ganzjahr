ids<-c(ids,el$id[indices_inel_children[j]])
}
}
}
new_var<-data.frame(id=var_id,partition=part_id,fahrlage=r$fahrlage[rows[1]],von=r$von[rows[1]],bis=r$bis[rows[1]],
valid=1,abgelehnt=0,minFahrzeit=spath$length,homogen=r$homogen[rows[1]],
res=toString(ids))
var_bits<-r[0,11:(10+n)]
var_bits[1,]<-spath$bits
new_var<-cbind(new_var,var_bits)
# Update appendix of r data frame that contains the varianten of the current partition
if(!is.null(new_part)){
new_part<-rbind(new_part,new_var)
}else{
new_part<-new_var
}
# Update the bits that are still missing
bits_flg<-bits_flg-spath$bits
bits_flg
sum(bits_flg)
var_id<-max(max(new_part$id),max(r$id))+1
wegeSuche_count_temp<-wegeSuche_count_temp+1
try(spath<-bellmanford_bitconstr(el_temp,v_top,bits_flg,1,n))
if(length(spath)==0){
print("Es konnte kein Weg mehr gefunden werden mit der aktuellen Bitleiste")
break
}
spath
## Add relevante Children der in dem Weg benutzen Parents zum Solution Space
indices_ineltemp_parents<-as.integer(spath$epath)
ids<-c()
for(k in 1:length(indices_ineltemp_parents)){
indices_inel_children<-which((el$parent==el_temp$id[indices_ineltemp_parents[k]] & el$beenparent==0) |
(el$id==el_temp$id[indices_ineltemp_parents[k]] & el$beenparent==0))
## Falls Child Systemtrasse relevant (überschneidender Gültigkeitszeitraum), nimm hinzu
for(j in 1:length(indices_inel_children)){
if(length(which(r[i,11:(10+n)]==1 & el[indices_inel_children[j],7:(6+n)]==1))>0){
ids<-c(ids,el$id[indices_inel_children[j]])
}
}
}
new_var<-data.frame(id=var_id,partition=part_id,fahrlage=r$fahrlage[rows[1]],von=r$von[rows[1]],bis=r$bis[rows[1]],
valid=1,abgelehnt=0,minFahrzeit=spath$length,homogen=r$homogen[rows[1]],
res=toString(ids))
var_bits<-r[0,11:(10+n)]
var_bits[1,]<-spath$bits
new_var<-cbind(new_var,var_bits)
# Update appendix of r data frame that contains the varianten of the current partition
if(!is.null(new_part)){
new_part<-rbind(new_part,new_var)
}else{
new_part<-new_var
}
# Update the bits that are still missing
bits_flg<-bits_flg-spath$bits
## Add relevante Children der in dem Weg benutzen Parents zum Solution Space
indices_ineltemp_parents<-as.integer(spath$epath)
ids<-c()
for(k in 1:length(indices_ineltemp_parents)){
indices_inel_children<-which((el$parent==el_temp$id[indices_ineltemp_parents[k]] & el$beenparent==0) |
(el$id==el_temp$id[indices_ineltemp_parents[k]] & el$beenparent==0))
## Falls Child Systemtrasse relevant (überschneidender Gültigkeitszeitraum), nimm hinzu
for(j in 1:length(indices_inel_children)){
if(length(which(r[i,11:(10+n)]==1 & el[indices_inel_children[j],7:(6+n)]==1))>0){
ids<-c(ids,el$id[indices_inel_children[j]])
}
}
}
new_var<-data.frame(id=var_id,partition=part_id,fahrlage=r$fahrlage[rows[1]],von=r$von[rows[1]],bis=r$bis[rows[1]],
valid=1,abgelehnt=0,minFahrzeit=spath$length,homogen=r$homogen[rows[1]],
res=toString(ids))
var_bits<-r[0,11:(10+n)]
var_bits[1,]<-spath$bits
new_var<-cbind(new_var,var_bits)
# Update appendix of r data frame that contains the varianten of the current partition
if(!is.null(new_part)){
new_part<-rbind(new_part,new_var)
}else{
new_part<-new_var
}
# Update the bits that are still missing
bits_flg<-bits_flg-spath$bits
bits_flg
## Set Working Directory
setwd("~/02_Projekte/24_SAT und Ganzj Bel/Code")
### Load Libraries
library(igraph)
library(lpSolve)
### Load Functionalities
source("extend_solution_spaces.R")
source("encoding.R")
source("makro_konflikte.R")
source("mikro_konflikte.R")
source("sep_trassen.R")
source("block_trassen.R")
source("validity.R")
source("decoding.R")
source("bellmanford_bitconstr.R")
source("add_partition.R")
### Load and initialize Data
source("Tests/unit test trenne systrasse und fahrlage dynamisch.R")
## Lade Daten
data<-load_data()
el<-data$el
r<-data$r
n<-data$n
## Initialize ids
el$id<-1:nrow(el)
## Initialize topological ordering of vertices (To do: Compute the ordering here)
v_top<-c('Q','B','A','S')
## Suche Initial Wege für Solution Spaces und Zähler für Wegesuche
wegeSuche_count<-0
init<-extend_solution_spaces(el,r,1:nrow(r),n)
el<-init$el
r<-init$r
wegeSuche_count<-init$wegeSuche_count
## Initialisiere Validity
ablehnen_count<-length(unique(r$fahrlage))
r<-validity(r)
## Initialisiere Lösung
# Encode Initialdaten
enc<-encode(el,r)
A<-enc$A
dir<-enc$dir
b<-enc$b
omega<-enc$omega
# Solve SAT für Initialdaten
res<-lp(direction="max", objective.in=omega, const.mat=A, const.dir=dir, const.rhs=b, all.bin=TRUE)
## Initialisiere Zähler
stufe1_count<-0
stufe2_count<-0
## Set dynamische Schneideregel
dyn_split <- T
## Finde einen Makrokonflikt Fahrlagen
makro<-makro_konflikte(el[which(el$beenparent==0),],r[which(r$abgelehnt==0 & r$valid==1),])
print(makro)
## Finde einen Mikrokonflikt
benutzteSystemtrassen<-unique(as.integer(unlist(strsplit(r$res[which(r$valid==1 & r$fahrlage %in% makro)], split=", "))))
mikro<-mikro_konflikte(el[which(el$beenparent==0 & el$id %in% benutzteSystemtrassen),],r[which(r$valid==1),],makro)
print(mikro)
## Löse Mikrokonflikt
# 1. Versuche Systemtrassen aufzuteilen
nrow_el_alt<-nrow(el)
sep<-sep_trassen(el,r,n,mikro,makro)
el<-sep$el
r<-sep$r
# 2 Falls keine Systemtrasse geteilt werden konnte, sperre Mikrokonflikttrassen
#   im entsprechenden Konfliktzeitraum, um alternative Wege zu finden
#   Gehe vor nach Stufenprinzip
qual_max<-(-1000)
terminate<-FALSE
#terminate_local<-FALSE
## Sperre zunächst alle Systemtrassen (OR Verknüpfung) gemeinsam auf Konfliktzeit aller Fahrlagen im
## Makrokonflikt
el_blocked<-block_trassen(el,r,makro,mikro,n)
stufe1_count<-stufe1_count+1
i<-1
j<-1
fahrlage<-makro[i]
partitionen_ids<-unique(r$partition[which(r$partition %in% r$partition[which(r$fahrlage == fahrlage)])])
partition<-partitionen_ids[j]
varianten_indx<-which(r$id %in% r$id[which(r$fahrlage == fahrlage & r$partition == partition)])
if(dyn_split==T){
ex<-add_partition(el_blocked,r,varianten_indx,v_top,n) # Setze neue Partitionen
}
ex
el
### Set Working Directory
setwd("~/02_Projekte/24_SAT und Ganzj Bel/Code")
### Load Libraries
library(igraph)
library(lpSolve)
### Load Functionalities
source("extend_solution_spaces.R")
source("encoding.R")
source("makro_konflikte.R")
source("mikro_konflikte.R")
source("sep_trassen.R")
source("block_trassen.R")
source("validity.R")
source("decoding.R")
source("bellmanford_bitconstr.R")
source("add_partition.R")
### Load and initialize Data
source("Tests/unit test trenne systrasse und fahrlage dynamisch.R")
## Lade Daten
data<-load_data()
el<-data$el
r<-data$r
n<-data$n
## Initialize ids
el$id<-1:nrow(el)
## Initialize topological ordering of vertices (To do: Compute the ordering here)
v_top<-c('Q','B','A','S')
## Suche Initial Wege für Solution Spaces und Zähler für Wegesuche
wegeSuche_count<-0
init<-extend_solution_spaces(el,r,1:nrow(r),n)
el<-init$el
r<-init$r
wegeSuche_count<-init$wegeSuche_count
## Initialisiere Validity
ablehnen_count<-length(unique(r$fahrlage))
r<-validity(r)
## Initialisiere Lösung
# Encode Initialdaten
enc<-encode(el,r)
A<-enc$A
dir<-enc$dir
b<-enc$b
omega<-enc$omega
# Solve SAT für Initialdaten
res<-lp(direction="max", objective.in=omega, const.mat=A, const.dir=dir, const.rhs=b, all.bin=TRUE)
## Initialisiere Zähler
stufe1_count<-0
stufe2_count<-0
## Set dynamische Schneideregel
dyn_split <- T
### Solange das Gesamtproblem nicht lösbar ist...
while(res$status!=0){
## Finde einen Makrokonflikt Fahrlagen
makro<-makro_konflikte(el[which(el$beenparent==0),],r[which(r$abgelehnt==0 & r$valid==1),])
print(makro)
## Finde einen Mikrokonflikt
benutzteSystemtrassen<-unique(as.integer(unlist(strsplit(r$res[which(r$valid==1 & r$fahrlage %in% makro)], split=", "))))
mikro<-mikro_konflikte(el[which(el$beenparent==0 & el$id %in% benutzteSystemtrassen),],r[which(r$valid==1),],makro)
print(mikro)
## Löse Mikrokonflikt
# 1. Versuche Systemtrassen aufzuteilen
nrow_el_alt<-nrow(el)
sep<-sep_trassen(el,r,n,mikro,makro)
el<-sep$el
r<-sep$r
# 2 Falls keine Systemtrasse geteilt werden konnte, sperre Mikrokonflikttrassen
#   im entsprechenden Konfliktzeitraum, um alternative Wege zu finden
#   Gehe vor nach Stufenprinzip
if(nrow(el)==nrow_el_alt){
qual_max<-(-1000)
terminate<-FALSE
#terminate_local<-FALSE
## Sperre zunächst alle Systemtrassen (OR Verknüpfung) gemeinsam auf Konfliktzeit aller Fahrlagen im
## Makrokonflikt
el_blocked<-block_trassen(el,r,makro,mikro,n)
stufe1_count<-stufe1_count+1
for(i in 1:length(makro)){
fahrlage<-makro[i]
partitionen_ids<-unique(r$partition[which(r$partition %in% r$partition[which(r$fahrlage == fahrlage)])])
for(j in 1:length(partitionen_ids)){
partition<-partitionen_ids[j]
varianten_indx<-which(r$id %in% r$id[which(r$fahrlage == fahrlage & r$partition == partition)])
if(dyn_split==T){
ex<-add_partition(el_blocked,r,varianten_indx,v_top,n) # Setze neue Partitionen
}else{
ex<-extend_solution_spaces(el_blocked,r,varianten_indx,n) # Mach Wegesuche für alle Varianten der Partition j der Fahrlage i
}
r_candid<-ex$r
wegeSuche_count<-wegeSuche_count+ex$wegeSuche_count
qual_candid<-(2-(as.integer(apply(r[varianten_indx,11:(10+n)],1,sum))/n) %*%
r_candid$minFahrzeit[varianten_indx]/(min(r$minFahrzeit[which(r$fahrlage==fahrlage & r$minFahrzeit!=0)])))*r_candid$homogen[varianten_indx[1]]
# Wenn meine Qualitätskennzahl besser ist und neue Wege gefunden wurden (bzw. bei
# neuen Partitionen, ob alle Fahrlagenvarianten einen Weg haben), dann wird diese Partition mein Gewinner
if((!all(r_candid$res==r$res) | (r$valid[varianten_indx[1]]==0) & (all(r$res[varianten_indx]!="0"))) & qual_candid>qual_max){
qual_max<-qual_candid
fahrlage_gewinner<-fahrlage
partition_gewinner<-partition
r_gewinner<-r_candid
terminate<-TRUE
}
}
}
## Falls kein neuer Weg gefunden wurde, sperre Systemtrassen separat, aber auf Konfliktzeit aller Fahrlagen im
## Makrokonflikt
if(terminate==FALSE){
stufe1_count<-stufe1_count-1
stufe2_count<-stufe2_count+1
for(k in 0:length(mikro)){
## Schalte dazwischen: Wenn keine Trasse gesperrt wird, können dennoch neue Wege für neue Partitionen gefunden werden
if(k==0){
el_blocked<-el
}else{
el_blocked<-block_trassen(el,r,makro,mikro[k],n)
}
for(i in 1:length(makro)){
qual_max<-(-1000)
fahrlage<-makro[i]
partitionen_ids<-unique(r$partition[which(r$partition %in% r$partition[which(r$fahrlage == fahrlage)])])
for(j in 1:length(partitionen_ids)){
partition<-partitionen_ids[j]
varianten_indx<-which(r$id %in% r$id[which(r$fahrlage == fahrlage & r$partition == partition)])
if(dyn_split==T){
ex<-add_partition(el_blocked,r,varianten_indx,n) # Setze neue Partitionen
}else{
ex<-extend_solution_spaces(el_blocked,r,varianten_indx,n) # Mach Wegesuche für alle Varianten der Partition j der Fahrlage i
}
r_candid<-ex$r
wegeSuche_count<-wegeSuche_count+ex$wegeSuche_count
qual_candid<-(2-(as.integer(apply(r[varianten_indx,11:(10+n)],1,sum))/n) %*%
r_candid$minFahrzeit[varianten_indx]/(min(r$minFahrzeit[which(r$fahrlage==fahrlage & r$minFahrzeit!=0)])))*r_candid$homogen[varianten_indx[1]]
# Wenn meine Qualitätskennzahl besser ist und neue Wege gefunden wurden (bzw. bei
# neuen Partitionen, ob alle Fahrlagenvarianten einen Weg haben), dann wird diese Partition mein Gewinner
if((!all(r_candid$res==r$res) | (r$valid[varianten_indx[1]]==0) & (all(r$res[varianten_indx]!="0"))) & qual_candid>qual_max){
qual_max<-qual_candid
fahrlage_gewinner<-fahrlage
partition_gewinner<-partition
r_gewinner<-r_candid
terminate<-TRUE
}
}
}
}
}
if(terminate==TRUE){
## Ergänze r um neuen Weg/ neue Partition des Gewinners
r<-r_gewinner
indx_update<-which(r$partition==partition_gewinner & r$fahrlage==fahrlage_gewinner)
r$valid[indx_update]<-rep(1,length(indx_update))
print(paste("The winner is: Fahrlage ",fahrlage_gewinner," und Partition ",partition_gewinner,sep=""))
}
## Falls keine neuen Wege in keiner Stufe gefunden und der Konflikt demnach nicht aufgelöst wurde, lehne Fahrlagen ab
if(terminate==FALSE){
stufe2_count<-stufe2_count-1
ablehnung_id<-makro[length(makro)]
if(ablehnung_id==19){break}
r$abgelehnt[which(r$fahrlage==ablehnung_id)]<-rep(1,length(which(r$fahrlage==ablehnung_id)))
print(paste("Lehne Fahrlage ",ablehnung_id," ab.",sep=""))
}
}
## Encode
enc<-encode(el,r[which(r$abgelehnt==0 & r$valid==1),])
A<-enc$A
dir<-enc$dir
b<-enc$b
omega<-enc$omega
print(dim(A))
## Solve SAT
res<-lp(direction="max", objective.in=omega, const.mat=A, const.dir=dir, const.rhs=b, all.bin=TRUE)
}
r
## Set Working Directory
setwd("~/02_Projekte/24_SAT und Ganzj Bel/Code")
### Load Libraries
library(igraph)
library(lpSolve)
### Load Functionalities
source("extend_solution_spaces.R")
source("encoding.R")
source("makro_konflikte.R")
source("mikro_konflikte.R")
source("sep_trassen.R")
source("block_trassen.R")
source("validity.R")
source("decoding.R")
source("bellmanford_bitconstr.R")
source("add_partition.R")
### Load and initialize Data
source("Tests/unit test trenne systrasse und fahrlage dynamisch.R")
## Lade Daten
data<-load_data()
el<-data$el
r<-data$r
n<-data$n
## Initialize ids
el$id<-1:nrow(el)
## Initialize topological ordering of vertices (To do: Compute the ordering here)
v_top<-c('Q','B','A','S')
## Suche Initial Wege für Solution Spaces und Zähler für Wegesuche
wegeSuche_count<-0
init<-extend_solution_spaces(el,r,1:nrow(r),n)
el<-init$el
r<-init$r
wegeSuche_count<-init$wegeSuche_count
## Initialisiere Validity
ablehnen_count<-length(unique(r$fahrlage))
r<-validity(r)
## Initialisiere Lösung
# Encode Initialdaten
enc<-encode(el,r)
A<-enc$A
dir<-enc$dir
b<-enc$b
omega<-enc$omega
# Solve SAT für Initialdaten
res<-lp(direction="max", objective.in=omega, const.mat=A, const.dir=dir, const.rhs=b, all.bin=TRUE)
## Initialisiere Zähler
stufe1_count<-0
stufe2_count<-0
## Set dynamische Schneideregel
dyn_split <- T
## Finde einen Makrokonflikt Fahrlagen
makro<-makro_konflikte(el[which(el$beenparent==0),],r[which(r$abgelehnt==0 & r$valid==1),])
print(makro)
## Finde einen Mikrokonflikt
benutzteSystemtrassen<-unique(as.integer(unlist(strsplit(r$res[which(r$valid==1 & r$fahrlage %in% makro)], split=", "))))
mikro<-mikro_konflikte(el[which(el$beenparent==0 & el$id %in% benutzteSystemtrassen),],r[which(r$valid==1),],makro)
print(mikro)
## Löse Mikrokonflikt
# 1. Versuche Systemtrassen aufzuteilen
nrow_el_alt<-nrow(el)
sep<-sep_trassen(el,r,n,mikro,makro)
el<-sep$el
r<-sep$r
# 2 Falls keine Systemtrasse geteilt werden konnte, sperre Mikrokonflikttrassen
#   im entsprechenden Konfliktzeitraum, um alternative Wege zu finden
#   Gehe vor nach Stufenprinzip
qual_max<-(-1000)
terminate<-FALSE
#terminate_local<-FALSE
## Sperre zunächst alle Systemtrassen (OR Verknüpfung) gemeinsam auf Konfliktzeit aller Fahrlagen im
## Makrokonflikt
el_blocked<-block_trassen(el,r,makro,mikro,n)
stufe1_count<-stufe1_count+1
i<-1
fahrlage<-makro[i]
partitionen_ids<-unique(r$partition[which(r$partition %in% r$partition[which(r$fahrlage == fahrlage)])])
j<-1
partition<-partitionen_ids[j]
varianten_indx<-which(r$id %in% r$id[which(r$fahrlage == fahrlage & r$partition == partition)])
if(dyn_split==T){
ex<-add_partition(el_blocked,r,varianten_indx,v_top,n) # Setze neue Partitionen
}
r_candid<-ex$r
r_candid
wegeSuche_count<-wegeSuche_count+ex$wegeSuche_count
qual_candid<-(2-(as.integer(apply(r[varianten_indx,11:(10+n)],1,sum))/n) %*%
r_candid$minFahrzeit[varianten_indx]/(min(r$minFahrzeit[which(r$fahrlage==fahrlage & r$minFahrzeit!=0)])))*r_candid$homogen[varianten_indx[1]]
qual_candid
(!all(r_candid$res==r$res) | (r$valid[varianten_indx[1]]==0) & (all(r$res[varianten_indx]!="0"))) & qual_candid>qual_max
qual_max<-qual_candid
fahrlage_gewinner<-fahrlage
partition_gewinner<-partition
r_gewinner<-r_candid
terminate<-TRUE
## Encode
enc<-encode(el,r[which(r$abgelehnt==0 & r$valid==1),])
A<-enc$A
dir<-enc$dir
b<-enc$b
omega<-enc$omega
print(dim(A))
## Solve SAT
res<-lp(direction="max", objective.in=omega, const.mat=A, const.dir=dir, const.rhs=b, all.bin=TRUE)
res
## Finde einen Makrokonflikt Fahrlagen
makro<-makro_konflikte(el[which(el$beenparent==0),],r[which(r$abgelehnt==0 & r$valid==1),])
print(makro)
## Finde einen Mikrokonflikt
benutzteSystemtrassen<-unique(as.integer(unlist(strsplit(r$res[which(r$valid==1 & r$fahrlage %in% makro)], split=", "))))
mikro<-mikro_konflikte(el[which(el$beenparent==0 & el$id %in% benutzteSystemtrassen),],r[which(r$valid==1),],makro)
print(mikro)
## Löse Mikrokonflikt
# 1. Versuche Systemtrassen aufzuteilen
nrow_el_alt<-nrow(el)
sep<-sep_trassen(el,r,n,mikro,makro)
el<-sep$el
r<-sep$r
nrow(el)==nrow_el_alt
qual_max<-(-1000)
terminate<-FALSE
#terminate_local<-FALSE
## Sperre zunächst alle Systemtrassen (OR Verknüpfung) gemeinsam auf Konfliktzeit aller Fahrlagen im
## Makrokonflikt
el_blocked<-block_trassen(el,r,makro,mikro,n)
stufe1_count<-stufe1_count+1
r
## Ergänze r um neuen Weg/ neue Partition des Gewinners
r<-r_gewinner
indx_update<-which(r$partition==partition_gewinner & r$fahrlage==fahrlage_gewinner)
r$valid[indx_update]<-rep(1,length(indx_update))
print(paste("The winner is: Fahrlage ",fahrlage_gewinner," und Partition ",partition_gewinner,sep=""))
r
if((!all(r_candid$res==r$res) | (r$valid[varianten_indx[1]]==0) & (all(r$res[varianten_indx]!="0"))) & qual_candid>qual_max){
qual_max<-qual_candid
fahrlage_gewinner<-fahrlage
partition_gewinner<-partition
r_gewinner<-r_candid
terminate<-TRUE
}
r_gewinner
which(r$partition==partition_gewinner & r$fahrlage==fahrlage_gewinner)
r
## Finde einen Makrokonflikt Fahrlagen
makro<-makro_konflikte(el[which(el$beenparent==0),],r[which(r$abgelehnt==0 & r$valid==1),])
print(makro)
## Finde einen Mikrokonflikt
benutzteSystemtrassen<-unique(as.integer(unlist(strsplit(r$res[which(r$valid==1 & r$fahrlage %in% makro)], split=", "))))
mikro<-mikro_konflikte(el[which(el$beenparent==0 & el$id %in% benutzteSystemtrassen),],r[which(r$valid==1),],makro)
print(mikro)
## Löse Mikrokonflikt
# 1. Versuche Systemtrassen aufzuteilen
nrow_el_alt<-nrow(el)
sep<-sep_trassen(el,r,n,mikro,makro)
el<-sep$el
r<-sep$r
qual_max<-(-1000)
terminate<-FALSE
#terminate_local<-FALSE
## Sperre zunächst alle Systemtrassen (OR Verknüpfung) gemeinsam auf Konfliktzeit aller Fahrlagen im
## Makrokonflikt
el_blocked<-block_trassen(el,r,makro,mikro,n)
stufe1_count<-stufe1_count+1
el
i<-1
fahrlage<-makro[i]
partitionen_ids<-unique(r$partition[which(r$partition %in% r$partition[which(r$fahrlage == fahrlage)])])
length(partitionen_ids)
j<-1
partition<-partitionen_ids[j]
varianten_indx<-which(r$id %in% r$id[which(r$fahrlage == fahrlage & r$partition == partition)])
varianten_indx
if(dyn_split==T){
ex<-add_partition(el_blocked,r,varianten_indx,v_top,n) # Setze neue Partitionen
}
ex
